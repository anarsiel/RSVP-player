# RSVP-player
Текстовый плеер, основанный на технологии RSVP, для быстрого чтения текстов.

## Запуск
`$ python player.py`

## Управление

`Space`         - Начать/остановить проигрывание слов

`Up`, `Down`    - Увеличить/Уменьшить скорость воспроизведния на 10 wpm (words per minute)

`Left`, `Right` - показать предыдущее/следующее слово

`Shift`         - Перезапустить текущий файл

`Alt`           - Открыть файл файл, имя которого указано в текстовом поле

## Фичи (видимые для пользователя)

1. Запоминание прогресса. Программа помнит, где она остановилась для каждого файла, который открывала.
2. Индикатор прогресса. Программа отбражает при помощи, какая часть файла была прочтена.
3. Индикатор вкл/выкл. На маленьких wpm из-за большой паузы не всегда ясно, работает плеер или нет. 

## Фичи (не видимые для пользователя)

1. Возможность добавлять файл с настройками по умолчанию. Wpm, приветственная фраза, имя файла для чтения по умолчанию и др.
параметры могут настраиваться в этом файле.

2. Структура модулей обладает сильной связанностью и слабым зацеплением. Вместо Model.py может быть легко подключена любая БД, а
Qt может быть замененена на любую другую GUI библиотеку.

3. Исключения. Продуманная и полная система исключений повышает читаемость кода, облегчает отладку (поиск ошибок) и
 позволяет реализовать код без излишнего копирования.

## Подробнее про исключения

 Исключения делятся на два вида: вызывающие и не вызывающие экстренное завершение программы.
 Такая система позволяет соблюсти баланс между отказоустойчивостью кода и легкоизменяемостью.
 
 Никакие действия пользователя не могут породить исключения первого вида, однако они могут быть вызваны непосредственным
 вмешательством в исходный код программы. Это необходимо, чтобы ошибки обнаруживались ещё на этапе компиляции проекта, 
 если другой программист, который решит использовать этот исходный код, начнет неверно его изменять.

## Основные программные модули - front/body/back

### `Bridge.py` - front
Класс, реализуиющий интерфейс взаимодействия между фронтом (`.qml`) и контроллером.

### `Controller.py` - body
Реализует всю логику и взаимодействие между модулями.

### `Model.py` - back

Реализует интерфейс взаимодействия контроллера с данными.

### `Validator.py` - body
Ну это валидатор. Он... ну... валидирует. Код валидатора легко расширяемый: чтобы добавить новый параметр валидации
(например `age`, если мы вдруг захотим, чтобы нашим приложением не могли пользоваться дети) необходимо просто реализовать
функцию `__validate_age()` и добавить соответвующую пару `age` - `__validate_age` в словарь. Никакой копипасты и
дополнительных if-ов, а следовательно и никаких ошибок.

### `RsvppsFileParser.py` - body
Это парсер для файлов с расширением `.rsvpps` (rsvp player settings), устойчивый к некорректному синтаксису. Если в какая-то
из строчек будет некорректного формата, или в ней будет неверное имя параметра, то это не повлияет на работу парсера: все
корректные пары {параметр - значение} из предыдущих и последующих строчек будут учтены. На случай, если для какого-то
параметра задано невалидное значение или не задано вовсе, в коде программы захардкожены дефолные значения.

Сообщение об ошибке логгируется в консоль. Пример:

  ```
  WARNING:root:Error in line 4. Incorrect value: -239. Speed cannot be less than 0
  WARNING:root:Error in line 7. Incorrect value: . Greeting message cannot be empty string
  ```

В каждую строчку в любое место может быть добавлено любое число пробелов или их может не быть совсем. Любой ключ или значение
может состоять из пробелов, для этого нужно обернуть их в " или '.

Реализована поддержка `# комментариев`

### `Timer.py` - front
Класс, реализующий интерфейс взаимодействия с Qt-шным таймером.

Некоторые функции в контроллере требуют взаимодействия с Qt-шным таймером (например нужно остановить таймер 
при смене ресурса), однако его нельзя просто взять и добавить в контроллер, т.к. он является частью Qt, и мы таким образом
увеличим зацепление между фронтом и основной частью программы. Завернув класс QTimer в наш самописный Timer мы сможем
инкапсулировать всю Qt-ную часть в отдельном файле, а логику оставить в контроллере.

## Планируемые улучшения
1. Добавить на главный экран значение `ETL` (estimated time left) - время которое потребуется чтобы дочитать книгу, если
продолжить читать с такой же скоростью.
2. Сохранение настроек при перезапуске программы. Я уже подготовил для этого всю необходимую базу: необходимо записать
в соответсвующий файл `.rsvpps` имена файлов и номер слова, на котором в прошлый раз мы остановили чтение, и считывать 
эту информацию при запуске плеера.
3. Добавить селектор выбора файлов.
